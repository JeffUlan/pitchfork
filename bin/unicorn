#!/home/ew/bin/ruby
STDIN.sync = STDOUT.sync = STDERR.sync = true
require 'unicorn' # require this first to populate Unicorn::DEFAULT_START_CTX
require 'rack'
require 'optparse'

env = "development"
daemonize = false
listeners = []
options = { :listeners => listeners }
host = Unicorn::Const::DEFAULT_HOST
port = Unicorn::Const::DEFAULT_PORT

opts = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: #{File.basename($0)} " \
                "[ruby options] [unicorn options] [rackup config file]"

  opts.separator ""
  opts.separator "Ruby options:"

  lineno = 1
  opts.on("-e", "--eval LINE", "evaluate a LINE of code") do |line|
    eval line, TOPLEVEL_BINDING, "-e", lineno
    lineno += 1
  end

  opts.on("-d", "--debug", "set debugging flags (set $DEBUG to true)") do
    $DEBUG = true
  end

  opts.on("-w", "--warn", "turn warnings on for your script") do
    $-w = true
  end

  opts.on("-I", "--include PATH",
          "specify $LOAD_PATH (may be used more than once)") do |path|
    $LOAD_PATH.unshift(*path.split(/:/))
  end

  opts.on("-r", "--require LIBRARY",
          "require the library, before executing your script") do |library|
    require library
  end

  opts.separator ""
  opts.separator "Unicorn options:"

  # some of these switches exist for rackup command-line compatibility,

  opts.on("-o", "--host HOST",
          "listen on HOST (default: #{Unicorn::Const::DEFAULT_HOST})") do |h|
    host = h
  end

  opts.on("-p", "--port PORT",
          "use PORT (default: #{Unicorn::Const::DEFAULT_PORT})") do |p|
    port = p.to_i
  end

  opts.on("-E", "--env ENVIRONMENT",
          "use ENVIRONMENT for defaults (default: development)") do |e|
    env = e
  end

  opts.on("-D", "--daemonize", "run daemonized in the background") do |d|
    daemonize = d ? true : false
  end

  # Unicorn-specific stuff
  opts.on("-l", "--listen {HOST:PORT|PATH}",
          "listen on HOST:PORT or PATH",
          "this may be specified multiple times",
          "(default: #{Unicorn::Const::DEFAULT_LISTEN})") do |address|
    listeners << address
  end

  opts.on("-C", "--directory PATH", "run in this directory") do |d|
    options[:directory] = d
  end

  opts.on("-c", "--config-file FILE", "Unicorn-specific config file") do |f|
    options[:config_file] = File.expand_path(f)
  end

  # I'm avoiding Unicorn-specific config options on the command-line.
  # IMNSHO, config options on the command-line are redundant given
  # config files and make things unnecessarily complicated with multiple
  # places to look for a config option.

  opts.separator ""
  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on_tail("-v", "--version", "Show version") do
    puts "unicorn v#{Unicorn::Const::UNICORN_VERSION}"
    exit
  end

  opts.parse! ARGV
end

require 'pp' if $DEBUG

config = ARGV[0] || "config.ru"
abort "configuration file #{config} not found" unless File.exist?(config)

if config =~ /\.ru$/
  cfgfile = File.read(config)
  if cfgfile[/^#\\(.*)/]
    warn %(not parsing embedded command-line options: "#$1")
  end
  inner_app = eval "Rack::Builder.new {(#{cfgfile}\n)}.to_app", nil, config
else
  require config
  inner_app = Object.const_get(File.basename(config, '.rb').capitalize)
end

app = case env
when "development"
  Rack::Builder.new do
    use Rack::CommonLogger, STDERR
    use Rack::ShowExceptions
    use Rack::Lint
    run inner_app
  end.to_app
when "deployment"
  Rack::Builder.new do
    use Rack::CommonLogger, STDERR
    run inner_app
  end.to_app
else
  inner_app
end

if listeners.empty?
  listener = "#{host}:#{port}"
  listeners << listener if listener != Unicorn::Const::DEFAULT_LISTEN
end

if $DEBUG
  pp({
    :unicorn_options => options,
    :app => app,
    :inner_app => inner_app,
    :daemonize => daemonize,
  })
end

# only daemonize if we're not inheriting file descriptors from our parent
if daemonize
  unless ENV['UNICORN_FD']
    exit if fork
    Process.setsid
    exit if fork
  end

  Dir.chdir("/") # setting options[:directory] will override this later on
  File.umask(0000)
  STDIN.reopen("/dev/null")

  # we can redirect these again in the Unicorn {before,after}_fork hooks
  STDOUT.reopen("/dev/null", "a")
  STDERR.reopen("/dev/null", "a")
end

Unicorn.run(app, options)
