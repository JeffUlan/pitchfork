#!/home/ew/bin/ruby
$stdin.sync = $stdout.sync = $stderr.sync = true
require 'unicorn' # require this first to populate Unicorn::DEFAULT_START_CTX
require 'optparse'

env = "development"
daemonize = false
listeners = []
options = { :listeners => listeners }
host = Unicorn::Const::DEFAULT_HOST
port = Unicorn::Const::DEFAULT_PORT

opts = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: #{File.basename($0)} " \
                "[ruby options] [unicorn options] [rackup config file]"

  opts.separator "Ruby options:"

  lineno = 1
  opts.on("-e", "--eval LINE", "evaluate a LINE of code") do |line|
    eval line, TOPLEVEL_BINDING, "-e", lineno
    lineno += 1
  end

  opts.on("-d", "--debug", "set debugging flags (set $DEBUG to true)") do
    $DEBUG = true
  end

  opts.on("-w", "--warn", "turn warnings on for your script") do
    $-w = true
  end

  opts.on("-I", "--include PATH",
          "specify $LOAD_PATH (may be used more than once)") do |path|
    $LOAD_PATH.unshift(*path.split(/:/))
  end

  opts.on("-r", "--require LIBRARY",
          "require the library, before executing your script") do |library|
    require library
  end

  opts.separator "Unicorn options:"

  # some of these switches exist for rackup command-line compatibility,

  opts.on("-o", "--host HOST",
          "listen on HOST (default: #{Unicorn::Const::DEFAULT_HOST})") do |h|
    host = h
  end

  opts.on("-p", "--port PORT",
          "use PORT (default: #{Unicorn::Const::DEFAULT_PORT})") do |p|
    port = p.to_i
  end

  opts.on("-E", "--env ENVIRONMENT",
          "use ENVIRONMENT for defaults (default: development)") do |e|
    env = e
  end

  opts.on("-D", "--daemonize", "run daemonized in the background") do |d|
    daemonize = d ? true : false
  end

  # Unicorn-specific stuff
  opts.on("-l", "--listen {HOST:PORT|PATH}",
          "listen on HOST:PORT or PATH",
          "this may be specified multiple times",
          "(default: #{Unicorn::Const::DEFAULT_LISTEN})") do |address|
    listeners << address
  end

  opts.on("-c", "--config-file FILE", "Unicorn-specific config file") do |f|
    options[:config_file] = File.expand_path(f)
  end

  # I'm avoiding Unicorn-specific config options on the command-line.
  # IMNSHO, config options on the command-line are redundant given
  # config files and make things unnecessarily complicated with multiple
  # places to look for a config option.

  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on_tail("-v", "--version", "Show version") do
    puts "unicorn v#{Unicorn::Const::UNICORN_VERSION}"
    exit
  end

  opts.parse! ARGV
end

require 'pp' if $DEBUG

# require Rack as late as possible in case $LOAD_PATH is modified
# in config.ru or command-line
require 'rack'

config = ARGV[0] || "config.ru"
abort "configuration file #{config} not found" unless File.exist?(config)

inner_app = case config
when /\.ru$/
  raw = File.open(config, "rb") { |fp| fp.sysread(fp.stat.size) }
  # parse embedded command-line options in config.ru comments
  if raw[/^#\\(.*)/]
    opts.parse! $1.split(/\s+/)
  end
  lambda { || eval("Rack::Builder.new {(#{raw}\n)}.to_app", nil, config) }
else
  lambda do ||
    require config
    Object.const_get(File.basename(config, '.rb').capitalize)
  end
end

app = case env
when "development"
  lambda do ||
    Rack::Builder.new do
      use Rack::CommonLogger, $stderr
      use Rack::ShowExceptions
      use Rack::Lint
      run inner_app.call
    end.to_app
  end
when "deployment"
  lambda do ||
    Rack::Builder.new do
      use Rack::CommonLogger, $stderr
      run inner_app.call
    end.to_app
  end
else
  inner_app
end

if listeners.empty?
  listener = "#{host}:#{port}"
  listeners << listener
end

if $DEBUG
  pp({
    :unicorn_options => options,
    :app => app,
    :inner_app => inner_app,
    :daemonize => daemonize,
  })
end

# only daemonize if we're not inheriting file descriptors from our parent
if daemonize

  $stdin.reopen("/dev/null")
  unless ENV['UNICORN_FD']
    exit if fork
    Process.setsid
    exit if fork
  end

  # We don't do a lot of standard daemonization stuff:
  #   * $stderr/$stderr can/will be redirected separately
  #   * umask is whatever was set by the parent process at startup
  #     and can be set in config.ru and config_file, so making it
  #     0000 and potentially exposing sensitive log data can be bad
  #     policy.
  #   * Don't bother to chdir here since Unicorn is designed to
  #     run inside APP_ROOT.  Unicorn will also re-chdir() to
  #     the directory it was started in when being re-executed
  #     to pickup code changes if the original deployment directory
  #     is a symlink or otherwise got replaced.
end

Unicorn.run(app, options)
