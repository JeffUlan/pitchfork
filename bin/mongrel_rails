require 'rubygems'
require 'mongrel'
require 'daemons/daemonize'
require 'mongrel/command'


class RailsHandler < Mongrel::HttpHandler

  def initialize(dir, mime_map = {})
    @files = Mongrel::DirHandler.new(dir,false)
    @guard = Mutex.new
    
    # register the requested mime types
    mime_map.each {|k,v| Mongrel::DirHandler::add_mime_type(k,v) }
  end
  
  def process(request, response)
    # not static, need to talk to rails
    return if response.socket.closed?

    if @files.can_serve(request.params["PATH_INFO"])
      @files.process(request,response)
    else
      cgi = Mongrel::CGIWrapper.new(request, response)

      begin
        @guard.synchronize do
          # Rails is not thread safe so must be run entirely within synchronize 
          Dispatcher.dispatch(cgi, ActionController::CgiRequest::DEFAULT_SESSION_OPTIONS, response.body)
        end

        # This finalizes the output using the proper HttpResponse way
        cgi.out {""}
      rescue Object => rails_error
        STDERR.puts "calling Dispatcher.dispatch #{rails_error}"
        STDERR.puts rails_error.backtrace.join("\n")
      end
    end

  end
end



class StartCommand < Mongrel::Command::Command

  def configure
    options [
             ["-e", "--environment ENV", "Rails environment to run as", :@environment, ENV['RAILS_ENV'] || "development"],
             ["-d", "--daemonize", "Whether to run in the background or not", :@daemon, false],
             ['-p', '--port PORT', "Which port to bind to", :@port, 3000],
             ['-a', '--address ADDR', "Address to bind to", :@address, "0.0.0.0"],
             ['-l', '--log FILE', "Where to write log messages", :@log_file, "log/mongrel.log"],
             ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/mongrel.pid"],
             ['-n', '--num-procs INT', "Number of processor threads to use", :@num_procs, 20],
             ['-t', '--timeout SECONDS', "Timeout all requests after SECONDS time", :@timeout, 120],
             ['-m', '--mime PATH', "A YAML file that lists additional MIME types", :@mime_map, nil],
             ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
             ['-r', '--root PATH', "Set the document root (default 'public')", :@docroot, "public"],
    ]
  end
  
  def validate
    @cwd = File.expand_path(@cwd)
    valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

    # change there to start, then we'll have to come back after daemonize
    Dir.chdir(@cwd)

    valid_dir? File.dirname(@log_file), "Path to log file not valid: #@log_file"
    valid_dir? File.dirname(@pid_file), "Path to pid file not valid: #@pid_file"
    valid_dir? @docroot, "Path to docroot not valid: #@docroot"
    valid_exists? @mime_map, "MIME mapping file does not exist: #@mime_map" if @mime_map

    return @valid
  end

  def daemonize 
    # save this for later since daemonize will hose it
    if @daemon
      puts "Started Mongrel server in #@environment mode at #@address:#@port"
      Daemonize.daemonize(log_file=File.join(@cwd, @log_file))

      # change back to the original starting directory
      Dir.chdir(@cwd)

      open(@pid_file,"w") {|f| f.write(Process.pid) }
    else
      puts "Running Mongrel server in #@environment mode at #@address:#@port"
    end
  end   

  def load_mime_map
    mime = {}

    # configure any requested mime map
    if @mime_map
      puts "Loading additional MIME types from #@mime_map"
      mime.merge!(YAML.load_file(@mime_map))

      # check all the mime types to make sure they are the right format
      mime.each {|k,v| puts "WARNING: MIME type #{k} must start with '.'" if k.index(".") != 0 }
    end
    
    return mime
  end

  def configure_rails
    ENV['RAILS_ENV'] = @environment
    require 'config/environment'

    # configure the rails handler
    rails = RailsHandler.new(@docroot, load_mime_map)
    
    return rails
  end

  def start_mongrel(rails)
    # start up mongrel with the right configurations
    server = Mongrel::HttpServer.new(@address, @port, @num_procs.to_i, @timeout.to_i)
    server.register("/", rails)
    server.run
    
    begin
      puts "Server ready."
      server.acceptor.join
    rescue Interrupt
      puts "Interrupted."
    end
  end

  def run
    daemonize
    rails = configure_rails
    start_mongrel(rails)
  end
end



class StopCommand < Mongrel::Command::Command

  def configure 
    options [
             ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
             ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/mongrel.pid"]
    ]
  end
  
  def validate
    @cwd = File.expand_path(@cwd)
    valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

    @pid_file = File.join(@cwd,@pid_file)
    valid_exists? @pid_file, "PID file #@pid_file does not exist. Not running?" 

    return @valid
  end

  
  def run
    pid = open(@pid_file).read.to_i
    print "Stopping Mongrel at PID #{pid}..."
    begin
      Process.kill("INT", pid)
    rescue Errno::ESRCH
      puts "Process does not exist.  Not running."
    end

    File.unlink(@pid_file)
    puts "Done."
  end
end




Mongrel::Command::Registry.instance.run ARGV
