require 'rubygems'
require 'mongrel/rails'
require 'yaml'



class Start < GemPlugin::Plugin "/commands"
  include Mongrel::Command::Base

  def configure
    options [
      ["-e", "--environment ENV", "Rails environment to run as", :@environment, ENV['RAILS_ENV'] || "development"],
      ["-d", "--daemonize", "Whether to run in the background or not", :@daemon, false],
      ['-p', '--port PORT', "Which port to bind to", :@port, 3000],
      ['-a', '--address ADDR', "Address to bind to", :@address, "0.0.0.0"],
      ['-l', '--log FILE', "Where to write log messages", :@log_file, "log/mongrel.log"],
      ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/mongrel.pid"],
      ['-n', '--num-procs INT', "Number of processor threads to use", :@num_procs, 20],
      ['-t', '--timeout SECONDS', "Timeout all requests after SECONDS time", :@timeout, 120],
      ['-m', '--mime PATH', "A YAML file that lists additional MIME types", :@mime_map, nil],
      ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
      ['-r', '--root PATH', "Set the document root (default 'public')", :@docroot, "public"],
    ]
  end
  
  def validate
    @cwd = File.expand_path(@cwd)
    valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

    # change there to start, then we'll have to come back after daemonize
    Dir.chdir(@cwd)

    valid_dir? File.dirname(@log_file), "Path to log file not valid: #@log_file"
    valid_dir? File.dirname(@pid_file), "Path to pid file not valid: #@pid_file"
    valid_dir? @docroot, "Path to docroot not valid: #@docroot"
    valid_exists? @mime_map, "MIME mapping file does not exist: #@mime_map" if @mime_map

    return @valid
  end


  def daemonize 
    # save this for later since daemonize will hose it
    if @daemon and RUBY_PLATFORM !~ /mswin/
      require 'daemons/daemonize'

      puts "Started Mongrel server in #@environment mode at #@address:#@port"
      Daemonize.daemonize(log_file=File.join(@cwd, @log_file))

      # change back to the original starting directory
      Dir.chdir(@cwd)

      open(@pid_file,"w") {|f| f.write(Process.pid) }
    else
      puts "Running Mongrel server in #@environment mode at #@address:#@port"
    end
  end   

  def load_mime_map
    mime = {}

    # configure any requested mime map
    if @mime_map
      puts "Loading additional MIME types from #@mime_map"
      mime.merge!(YAML.load_file(@mime_map))

      # check all the mime types to make sure they are the right format
      mime.each {|k,v| puts "WARNING: MIME type #{k} must start with '.'" if k.index(".") != 0 }
    end
    
    return mime
  end

  def configure_rails
    # need this later for safe reloading
    @orig_dollar_quote = $".clone

    ENV['RAILS_ENV'] = @environment
    require 'config/environment'
    require 'dispatcher'
    require 'cgi'

    # configure the rails handler
    rails = RailsHandler.new(@docroot, load_mime_map)
    
    return rails
  end

  def start_mongrel(rails)
    @restart = false

    server = Mongrel::HttpServer.new(@address, @port, @num_procs.to_i, @timeout.to_i)
    server.register("/", rails)

    # signal trapping just applies to posix systems
    # TERM is a valid signal, but still doesn't gracefuly shutdown on win32.
    if RUBY_PLATFORM !~ /mswin/
      # graceful shutdown
      trap("TERM") { 
        server.stop 
      }

      # rails reload
      trap("HUP") { 
        STDERR.puts "Reloading rails..."
        rails.reload!
        STDERR.puts "Done reloading rails."
      }

      # restart
      trap("USR2") { 
        server.stop
        @restart = true
      }
    end

    # hook up any rails specific plugins
    GemPlugin::Manager.instance.load "mongrel" => GemPlugin::INCLUDE

    begin
      # start mongrel processing thread
      server.run
      STDERR.puts "Server ready."
      server.acceptor.join
    rescue Interrupt
      STDERR.puts "Interrupted."
      raise
    end
    
    # daemonize makes restart easy
    run if @restart
  end

  def run
    daemonize
    rails = configure_rails
    start_mongrel(rails)
  end
end


def send_signal(signal, pid_file)
  pid = open(pid_file).read.to_i
  print "Sending #{signal} to Mongrel at PID #{pid}..."
  begin
    Process.kill(signal, pid)
  rescue Errno::ESRCH
    puts "Process does not exist.  Not running."
  end
  
  puts "Done."
end


class Stop < GemPlugin::Plugin "/commands"
  include Mongrel::Command::Base

  def configure 
    options [ 
             ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
             ['-f', '--force', "Force the shutdown.", :@force, false],
             ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/mongrel.pid"]
    ]
  end
  
  def validate
    @cwd = File.expand_path(@cwd)
    valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

    @pid_file = File.join(@cwd,@pid_file)
    valid_exists? @pid_file, "PID file #@pid_file does not exist. Not running?" 

    return @valid
  end

  
  def run
    if @force
      send_signal("KILL", @pid_file)
    else
      send_signal("TERM", @pid_file)
    end

    File.unlink(@pid_file)
  end
end



class Restart < GemPlugin::Plugin "/commands"
  include Mongrel::Command::Base

  def configure 
    options [ 
             ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
             ['-s', '--soft', "Do a soft restart rather than a process exit restart", :@soft, false],
             ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/mongrel.pid"]
    ]
  end
  
  def validate
    @cwd = File.expand_path(@cwd)
    valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

    @pid_file = File.join(@cwd,@pid_file)
    valid_exists? @pid_file, "PID file #@pid_file does not exist. Not running?" 

    return @valid
  end


  def run
    if @soft
      send_signal("HUP", @pid_file)
    else
      send_signal("USR2", @pid_file)
    end

    File.unlink(@pid_file)
  end
end

GemPlugin::Manager.instance.load "mongrel" => GemPlugin::INCLUDE, "rails" => GemPlugin::EXCLUDE

Mongrel::Command::Registry.instance.run ARGV
