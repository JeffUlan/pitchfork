---
title: FAQ
inMenu: true
directoryName: FAQ
ordering: 5
---

h1. FAQ

h2. Design

h3. Q: How does Mongrel relate to SCGI?

Mongrel and SCGI are *completely unrelated* except for the fact that I wrote 
the SCGI Rails Runner and Mongrel.

There has been some confusion by people as to how Mongrel and SCGI are related.  
Some folks actually think that Mongrel uses SCGI to run Ruby on Rails or other 
web applications.  Their confusion can be summarized in this diagram:

!images/mongrel_not_scgi.jpg!

As you can see on the *right*, Ruby on Rails (and other web apps) 
run *inside* Mongrel as just straight Ruby code and are served
using *regular HTTP*.  There are no:

# Additional network protocols other than HTTP.
# Started processes for each request.
# External connectors or libraries required.
# Additional server software.
# Need for SCGI at all ever no way.

In fact *you could drop lighttpd completely* from both diagrams and just serve
your Mongrel server straight to the network.


h3. Q: How is Mongrel designed?

The design of Mongrel most closely matches "Simple":http://simpleweb.sourceforge.net/ 
which is a very nicely designed web server framework for Java.  Despite being written
in Java Simple is very clean and simple, thus the name (clever eh?).  The main difference
between Mongrel and Simple is that Simple monitors returned output from handlers so that
it can modify the results.  Mongrel instead uses Ruby's blocks to get the same effect.

As for the internals of Mongrel there are a few key technologies being used:

* A custom HTTP 1.1 parser written based on the "RFC":http://www.w3.org/Protocols/rfc2616/rfc2616.html
  standard and using "an ABNF dump":http://www.cs.columbia.edu/sip/syntax/rfc2068.html thankfully
  put online by someone.  The parser is written using "Ragel":http://www.elude.ca/ragel/ and 
  is written C as a Ruby extension.
* A URIClassifier that uses a "Ternary Search Trie":http://www.octavian.org/cs/software.html
  written by Peter A. Friend and modified to quickly look up handlers for a URI based on
  a prefix.  This makes finding any handler from any URI quick and painless and is much
  faster than the alternative of parsing the path and using nested Hash structures.
* A simple server that uses the parser and URIClassifier to process requests, find the 
  right handlers, and then pass the results on to the handler for processing.
* Handlers are responsible for using HttpRequest and HttpResponse objects to do their
  thing and then return results.

Other than this there's not much more to it.

h3. Q: Is it multi-threaded or can it handle concurrent requests?

Mongrel is uses a pool of thread workers to do it's processing.  This means that
it is able to handle concurrent access and should be thread safe.  This also
means that you have to be more careful about how you use Mongrel.  You can't
just write your application assuming that there are no threads involved.

Camping and Og+Nitro are supposed to be thread safe and work with Mongrel directly.
This hasn't been heavily tested so people should let me know if they get weird
explosions under heavy load.

Ruby on Rails is not thread safe so there is a synchronized block around the calls
to Dispatcher.dispatch.  This means that everything is threaded right before and
right after Rails runs.  While Rails is running there is only one controller
in operation at a time.


h2. Web Site

h3. Q: How did you make this site?

The site was actually incredibly easy to create.  I simply went to "OSWD":http://openwebdesign.org/
and found a design that fit what I wanted for the site.  I then went to "Flickr":http://flickr.com/
and found pictures of various animals that were licensed under the 
"Creative Commons":http://creativecommons.org/ license.  Once I chopped the images up, worked them
into the design structure, and wrote an initial set of content I was done.

The tool I use to generate the site is called "webgen":http://webgen.rubyforge.org/ which
is a static site generator written in Ruby.  I write all of the content using redcloth
mark-up and leave the generation to webgen.  Finally I hooked into the Mongrel Rakefile
so that it's auto-generated and deployed to the site for me.

Refer to the "attributions":/attributions.html page for information on the resources used.


h2. Deployment

h3. Q: How do I deploy Mongrel in production?

Take a look at the "documentation pages":/docs/index.html for
information on deploying and enhancing Mongrel.  Feel free to
suggest documentation that you think is needed.


h3. Q: What does num-procs do?

There's two options that impact how your deployment performs
and what kind of resources it eats.

* num-procs -- Determines how many active requests are allowed
before clients are denied and old requests are killed off.
* timeout -- Determines a short sleep time between each client 
that is accepted.  This acts as a kind of throttle.

With num-procs you should think of it as the option that protects
your server from overload.  Let's say you set it to 100 and you
get 100 requests coming in that are all being worked on.  If 
request 101 comes in then that request gets closed immediately,
and Mongrel goes through the original 100 looking for requests to
kill off.  Right now it uses the timeout to come up with a reasonable
way to determine how long something is taking and will kill old
processors with an exception.

The timeout option is what you use if you want to make sure that
a Mongrel server can't take on too much work (i.e. you need to
throttle it).  What it does is sleep for N 100th/second after
each accept.  This means that it will slow down the number of 
incoming clients.  Very handy if you have a shared hosting system
and don't want people to eat your servers.


h3. Q: Mongrel stops working if it's left alone for a long time.

If you find that Mongrel stops working after a long idle time
and you're using MySQL then you're hitting a bug in the MySQL
driver that doesn't properly timeout connections.  What happens
is the MySQL *server* side of the connection times out and closes,
but the MySQL *client* doesn't detect this and just sits there.

What you have to do is set:

  ActiveRecord::Base.verification_timeout = 14400

Or to any value that is lower than the MySQL server's *interactive_timeout*
setting.  This will make sure that ActiveRecord checks the connection
often enough to reset the connection.


h3. Q: Why is the first request to Mongrel really slow?

The first request to *any* system will be slower than 
the others, you are just noticing it with Mongrel because
the difference is so much larger.

The cause of this depends on many factors, but typically it
is either Rails start-up, slow machine, no memory, or eager loading 
the world.  If you are on a slow box, or if you are trying to
load a huge amount of data when Rails starts, then the
first request will be nasty slow.

This shouldn't really bug you though unless it happens periodically
rather than from a cold start.  If it happens from a cold start or
after a long idle period then point your service monitor at your
application to keep it fresh.

If you run a long performance test and you see periodic pauses
then you may have a memory leak or not enough ram.  Re-run your
test while you monitor your ram with something like *top*.  If
you see the ram of Mongrel increase and then drop, or just increase,
or you see the swap grow and shrink, then you've got a memory leak
or just simply need more ram.

Debugging a leak is possible with the mongrel_rails start -B option.
It will log objects that get created to log/mongrel_debug and you can
look in there to find out what object is causing the problems.


